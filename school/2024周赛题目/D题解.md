# D谁还没吃到马斯卡彭

### 解题思路

这是一个经典的**约瑟夫问题**(**Josephus Problem**)的变种。该题通过模拟整个过程即可解决。


### 解题步骤

1. **初始化**：
   - 长度为 `n` 的数组 `a`，表示所有人都在圈中。
   - `a[i] = 0` 表示编号为 `i+1` 的人还在圈中。
   - `a[i] = -1` 表示编号为 `i+1` 的人已经退出。
2. **报数**：
   - 变量 `k` 来表示当前报数的位置，初始化为 `-1`（因为从第一个人开始报数，下标为 `0`）。
   - 变量 `count` 来记录已经吃到蛋糕的人数。
   - 使循环，直到 `count` 达到 `n-1`（即 `n-1` 个人已经吃到蛋糕）。
   - 在每次循环中，找到下一个报数到 `m` 的人，将其标记为 `-1`，并增加 `count`。
3. **求解**：
   - 遍历数组 `a`，找到唯一一个值为 `0` 的元素，其下标加 `1` 即为最后剩下的人的编号。

### AC代码
```c{.line-numbers}
#include<stdio.h>

int main(){
    int a[10001]={0}; //初始化化数组作为环
    int n,m;//n代表总的人数，m代表报数到几退出
    scanf("%d%d",&n,&m);
    int count=0;//记录退出的个数
    int k=-1;//这里假定开始为第一个人，下标为0，编号为1，如需从编号x开始，则k=x-2
    while(count<n-1){  //总共需要退出n-1个人
        int i=0;//记录当前报数编号
        while(i<m){
            k=(k+1)%n; //循环处理下标
            if(a[k]==0){
                i++;
                if(i==m){
                    a[k]=-1;
                    count++;
                }
            }
        }
    }
    for(int i=0;i<n;i++){
        if(a[i]==0){
            printf("%d\n",i+1);
            break;
        }
    }
    return 0;
}
```